# Terrateam Ansible engine

This project integrates Ansible automation into the Terrateam infrastructure-as-code workflow engine. The primary goal is to enable teams to manage both Terraform and Ansible operations seamlessly within Terrateam, supporting layered and multi-stage workflows across different environments and workspaces.

Preliminary capabilities include:

- Custom workflow definitions for Ansible playbooks, including init, plan, diff, and apply stages.

- Ansible config, galaxy install, and inventory support.

- Ansible apply based on static context, discovered in plan phase.

- Support for directory-based and workspace-based triggers, allowing fine-grained control over when Ansible code is executed.

- Support for layered runs and workspace-specific Ansible execution contexts.

- Debug and output hooks for enhanced visibility during CI/CD runs.

This setup is designed to help teams automate complex infrastructure and configuration management tasks, leveraging both Terraform and Ansible in a unified, auditable pipeline.

## Examples

- **day-2_ops1**: Demonstrates a basic Ansible playbook that performs a series of simple tasks on a localhost host reading parameters from a variable file.

- **day-2_ops2**: Demonstrates gathering collection from a git source using requirements files.  

- **day-2_ops3**: Demonstrates use of inventory.ini to provide host name and play variable.

- **day-2_ops4**: Demonstrates use of ansible.cfg to control ansible execution context.

- **terraform/day-1_cfg**: Contains the Terraform configuration for initial (Day 1) infrastructure provisioning, such as creating VMs, networks, or storage, which serves as the foundation for subsequent Ansible-driven Day 2 operations.

## Ansible and Terrateam life-cycle

Terrateam implements a Terraform-style lifecycle based on **init → plan → apply → output**, and applies the same model to Ansible. This approach aligns well with enterprise environments where execution requires plan approval, making Ansible workflows auditable and predictable in the same way as Terraform.

Ansible init detects requirements.yml file and install defined dependencies using ansible-galaxy. Plan executes ansible-inventory to transform potentially dynamic data generated by plugin into a static file. This step makes approver sure, that what he sees is whe he gets. Finally apply executes ansible-playbook in the context presented in plan. Output writes specified facts into output storage.

The workflow creates Ansible Native execution environment letting operator to run the playbook with whole context of settings from the CLI to be sure that exactly the same will be executed by the pipeline.

### Working directory

Terrateam configured with workspaces keep the current directory at repo root level, what does nto fit into Ansible, which feels the best having working directory on the level of playbook and accompanying files. All operations are always done form playbook's directory.

### ansible.cfg file detection

Ansible configuration file ansible.cfg placed in playbook directory will be used as it;s one of regular locations Ansible is looking for. Operator may use ansible.cfg to configure playbook's execution context.

### Galaxy install

Workflow expects requirements.yml file to be present in playbook's root directory, to install dependencies using regular ansible-galaxy install process. Collections are installed to regular system directory, that may be changed using ansible.cfg.

```bash
ansible-galaxy install -r requirements.yml
```

### Inventory support

Ansible supports two types of the inventory: static and dynamic generated by the plugin e.g. OCI collection plugin discovering OCI resources. The Ansible engine supports both expecting inventory.ini or inventory.yml file in playbook's directory, however always converting them into static yml format. Having this plugin based inventory created during a plan phase will be always passed to apply phase in the same form, even when external conditions will change e.g. new machines with given tags will be added to the system.

The conversion to a static form is performed using regular ansible way.

```bash
ansible-inventory -i inventory.yml  --list --export --yaml --output inventory_static.yml
```

### Playbook execution

Plan phase detects playbook to be executed. When more than one file is found, plan looks into ANSIBLE_PLAYBOOK file for a playbook filename. Having the name apply phase executes the playbook from its directory with static inventory file, and capture of stderr to separated file. Variable files are not applied to the CLI - the playbook should load variable files as required. 

```bash
cd $ANSIBLE_ROOT
ansible-playbook $PLAYBOOK -i inventory_static.yml 2> >(tee /tmp/ansible_stderr.log >&2)
```

Notice ANSIBLE_ROOT that is build out of active directory and a workspace name.

## Commit files in current repo

Ansible Terrateam kist comes with a script that commits files changed in current repository using Terrateam token available in the environment.

```bash
echo "Hello World by Ansible init!" > ${ANSIBLE_ROOT}/hello.txt
export COMMIT_MSG="hello.txt file updated"
${TERRATEAM_ROOT}/.terrateam/shared/commit.sh
```

TODO: Prepare Ansible role performing commit

## Output reception from Terraform

TBI

## Ansible output persistence

TBI

## Ansible engine scripts

Engine scripts are places in `.terrateam/ansible` directory, and registered in `.terrateam/config.yml` as ansible engine.

```yaml
  - tag_query: ANS_code
    engine:
      name: custom
      init:    ['${TERRATEAM_ROOT}/.terrateam/ansible/init.sh']
      plan:    ['${TERRATEAM_ROOT}/.terrateam/ansible/plan.sh', '$TERRATEAM_PLAN_FILE']
      diff:    ['${TERRATEAM_ROOT}/.terrateam/ansible/diff.sh', '$TERRATEAM_PLAN_FILE']
      apply:   ['${TERRATEAM_ROOT}/.terrateam/ansible/apply.sh']
      outputs: ['${TERRATEAM_ROOT}/.terrateam/ansible/outputs.sh']
    plan:
      - type: init
      - type: plan
    apply:
      - type: init
      - type: apply
```

Note that init is executed before both plan and apply, as Terrateam runs them in another execution environments.

*init.sh* - builds ANSIBLE_ROOT, and executed ansible-galaxy install.

*plan.sh* - discovers Ansible execution context to document it in a plan file. The plan file is handled by Terrateam to be passed to apply phase. Note that here potentially dynamic inventory is converted to static form.

*diff.sh* - converts the plan file to presentable format at Pull Request conversation.

*apply.sh* - unloads the plan to Ansible directory and execute ansible-playbook. In reality only inventory is unloaded as rest of the context is carried by gitHub repository.

*output.sh* - [Not yet implemented.] Writes Ansible facts to well known location. 
